"""Autocommiter Utility Functions"""

import datetime
import getpass
import os
import socket
import subprocess

from github import Github
from rich import print
from rich.prompt import Prompt


def is_git_installed():
    """
    The is_git_installed function checks if Git is installed on the system.
        It returns True if it is, and False otherwise.

    :return: A boolean value
    """
    try:
        # Use the 'git --version' command to check if Git is installed
        result = subprocess.run(["git", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        return "git version" in result.stdout
    except Exception as e:
        # Handle any exceptions that may occur during the check
        return False

def is_connected_to_internet():
    """
    The is_connected_to_internet function attempts to create a socket connection to a known external server.
    If the attempt is successful, it returns True. If not, it returns False.

    :return: True if the device is connected to the internet, and false otherwise
    """
    try:
        # Attempt to create a socket connection to a known external server
        socket.create_connection(("www.google.com", 80))
        return True
    except OSError:
        pass
    return False


def create_local_repository():
    """
    The create_local_repository function creates a local repository with the following structure:
        - Folder name (e.g., 'my-repo')
            - .github/workflows/main.yml (GitHub Actions file)
            - README.md (README file)
            - LICENSE (License file)

    :return: None
    """
    try:
        folder_name = Prompt.ask("Enter the folder name: ")
        if not folder_name:
            print("[red]Folder name cannot be empty.[/red]")
            return

        if os.path.exists(folder_name):
            print(f"[red]Folder '{folder_name}' already exists. Aborting.[/red]")
            return

        os.makedirs(folder_name)
        os.chdir(folder_name)
        subprocess.call(["git", "init"])

        os.makedirs(".github/workflows/")  # Create the workflows directory

        file_name = Prompt.ask("Enter the TXT file name: ")
        if not file_name:
            print("[red]File name cannot be empty.[/red]")
            return

        with open(f"{file_name}.txt", "w") as file:
            file.write(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        print("[green]Local Repository created successfully![/green]")

        schedule_time = Prompt.ask(
            "Enter the time to schedule the job (in UTC, e.g., 12:14): "
        )

        try:
            user_time = datetime.datetime.strptime(schedule_time, "%H:%M")
        except ValueError:
            print("[red]Invalid time format. Please use 'HH:MM' (e.g., 12:14).[/red]")
            return

        create_github_actions_file(file_name, user_time)
        create_readme(folder_name)
        generate_license("MIT")  # Add a license (e.g., MIT)
        subprocess.call(['git', 'add', "."])
        subprocess.call(['git', 'commit', '-m', 'Initial commit'])
        print("[green]Local Git repository configured successfully![/green]")

    except Exception as e:
        print(f"[red]An error occurred: {e}[/red]")


def create_github_actions_file(file_name, user_time):
    """
    The create_github_actions_file function creates a GitHub Actions workflow file that will automatically commit changes to the repository at the specified time.

    :param file_name: Specify the name of the file that will be created
    :param user_time: Get the time from the user
    """
    cron_expression = f"{user_time.minute} {user_time.hour} * * *"
    yaml_content = f"""
name: Auto Commit

on:
  schedule:
    - cron: '{cron_expression}'

permissions:
  contents: write

jobs:
  update-text-file:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Update TXT File
      run: echo $(date) >> {file_name}.txt

    - name: Commit Changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -am "Auto commit at $(date)"
        git push
    """

    with open(".github/workflows/auto_commit.yml", "w") as file:
        file.write(yaml_content)


def create_readme(folder_name):
    """
    The create_readme function creates a README.md file in the current working directory
    with some basic information about the repository and how to use it.


    :param folder_name: Create the header of the readme file
    """
    readme_content = f"# {folder_name}\n\n"  # Header with repository name
    readme_content += f"README File generated by Autocommiter tool.\n\n"  # Add user's username
    readme_content += "## About\n\n"
    readme_content += "This repository was generated using the autocommiter tool.\n\n"
    readme_content += "## Usage\n\n"
    readme_content += (
        "You can use this repository for your project or experiment with autocommiter. "
        "Feel free to customize this README to fit your needs.\n"
    )
    readme_content += "\n## License\n\n"
    readme_content += "This repository is licensed under the [MIT License](LICENSE).\n"

    with open("README.md", "w") as readme_file:
        readme_file.write(readme_content)


def generate_license(license_type):
    """
    The generate_license function generates a LICENSE file in the current directory.

    :param license_type: Determine which license to generate
    """
    license_content = f"""MIT License

Copyright (c) [year] [author's name]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

    with open("LICENSE", "w") as license_file:
        license_file.write(
            license_content.replace(
                "[year]", str(datetime.datetime.now().year)
            ).replace("[author's name]", "Your Name")
        )


def upload_to_github():
    """
    The upload_to_github function is used to upload the current directory to GitHub.
    It will prompt the user for a repository name and an access token, then create a new repository on GitHub with that name.
    After creating the repo, it will add it as a remote origin and push all files in this directory up to master.
    """
    try:
        repo_name = Prompt.ask("GitHub Repository Name: ")
        access_token = getpass.getpass("GitHub Access Token: ")

        g = Github(access_token)
        user = g.get_user()
        repo = user.create_repo(repo_name)


        subprocess.call(["git", "remote", "add", "origin", repo.clone_url])
        subprocess.call(["git", "push", "-u", "origin", "master"])
        print("[green]Repository successfully uploaded to GitHub![/green]")

    except Exception as e:
        print(f"[red]An error occurred: {e}[/red]")
